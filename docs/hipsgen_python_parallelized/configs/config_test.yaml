# =============================================================================
# HiPS Catalog Pipeline — config.yaml (Template)
# =============================================================================
# Configuration file for the modular package `hipsgen_cat`
#
# The pipeline:
#   - Reads large catalogs (Parquet / CSV / TSV / HATS)
#   - Distributes data with Dask (for Parquet/CSV/TSV) or LSDB (for HATS)
#   - Validates and normalizes RA/DEC (RA in degrees, DEC in degrees)
#   - Computes densmaps (per-depth HEALPix counts) and a MOC
#   - Selects sources per depth (coverage-based or global magnitude-based)
#   - Writes HiPS-compliant tiles (Norder*/Dir*/Npix*.tsv + Allsky.tsv)
#   - Produces MOC, density maps, metadata, and a process.log
#
# HATS catalogs:
#   - Opened via lsdb.open_catalog()
#   - Columns restricted to RA/DEC, score dependencies, mag_column (if mag_global)
#     plus any columns listed in columns.keep.
#   - When algorithm.use_hats_as_coverage=true, HATS partitions are used
#     as coverage cells (__icov__) instead of HEALPix coverage_order.
# =============================================================================


# -----------------------------------------------------------------------------
# Input catalog(s)
# -----------------------------------------------------------------------------
input:
  # List of input paths (files or directories). Supports wildcards.
  #   - Parquet/CSV/TSV → file paths or glob patterns.
  #   - HATS           → root catalog folder (where collection.properties lives).
  paths:
    - "/scratch/users/luigi.silva/data_preparation_results/lsst_dp1/DP_run_LSST_DP1_mag_cModelFlux_sfd_2025-10-29_15-57/LSST_DP1_mag_cModelFlux_sfd_collection"

  # Input format:
  #   "parquet" → Dask DataFrame via dd.read_parquet
  #   "csv"     → dd.read_csv (ASCII with delimiter auto-detected or ascii_format)
  #   "tsv"     → dd.read_csv with tab separator
  #   "hats"    → LSDB catalog opened via lsdb.open_catalog
  format: hats

  # For CSV/TSV only:
  #   header: true  → first row has column names
  #   header: false → no header; columns are accessed by 1-based indices
  #                   in the "columns" section (ra/dec/score).
  # Ignored for Parquet and HATS.
  # header: true

  # Optional hint for ASCII formats ("CSV" or "TSV").
  # Usually not needed; the separator is inferred from the extension.
  # Only used when format is "csv" or "tsv".
  # ascii_format: CSV


# -----------------------------------------------------------------------------
# Column mapping and score definition
# -----------------------------------------------------------------------------
columns:
  # RA/DEC column names or 1-based indices (if input.header=false for CSV/TSV).
  # Units must be degrees:
  #   - RA accepted in [0, 360) or [-180, 180] (internally normalized to [0, 360)).
  #   - DEC must be in [-90, 90].
  # Values outside these ranges cause a hard error.
  ra: coord_ra
  dec: coord_dec

  # Score expression used to rank sources within each coverage cell/tile.
  #
  #   - Can be a column name ("mag_r") or a Python expression using columns and
  #     numpy (np / numpy), e.g.: "(flux_g / err_g)**2".
  #   - Evaluated on pandas partitions; invalid/NaN/±inf values are handled
  #     and replaced with worst scores.
  #
  # order_desc=false → lower score is better (ascending sort).
  # order_desc=true  → higher score is better (descending sort).
  #
  # In coverage mode, this directly controls which rows are kept and how
  # fractional selection works inside each coverage cell.
  #
  # In mag_global mode, this expression is **not used at all**: selection is
  # purely based on mag_column and RA/DEC. The score still affects which
  # columns are requested from the input (score dependencies), but it does
  # not affect the selection logic.
  score: "i_cModelMag_dered"

  # Optional explicit list of columns to keep in output tiles.
  #
  # Behavior is unified across all formats (Parquet, CSV, TSV, HATS):
  #
  #   - If omitted or empty:
  #       → Keep only the minimal required subset:
  #           * RA and DEC columns;
  #           * any columns referenced in the score expression;
  #           * the magnitude column (if selection_mode = "mag_global").
  #
  #   - If provided:
  #       → Keep the union of:
  #           * the minimal subset above;
  #           * all column names listed here (filtered by availability).
  #
  # This restriction minimizes I/O and memory footprint while preserving all
  # necessary columns for selection and output.
  keep:
    - objectId
    - detect_fromBlend
    - detect_isDeblendedModelSource
    - detect_isIsolated
    - refExtendedness
    - tract
    - patch
    - u_cModelMag_dered
    - u_cModelMagErr_dered
    - g_cModelMag_dered
    - g_cModelMagErr_dered
    - r_cModelMag_dered
    - r_cModelMagErr_dered
    - i_cModelMag_dered
    - i_cModelMagErr_dered
    - z_cModelMag_dered
    - z_cModelMagErr_dered
    - y_cModelMag_dered
    - y_cModelMagErr_dered


# -----------------------------------------------------------------------------
# Algorithmic controls
# -----------------------------------------------------------------------------
algorithm:

  # ==============================
  # Shared core settings (both modes)
  # ==============================
  # Selection strategy:
  #   "coverage"   → coverage-based selection (k_per_cov, density profile, score).
  #   "mag_global" → global magnitude-complete selection (mag_column, mag_min/max).
  #
  # If you set "mag_global", the mag_* keys below become mandatory or
  # semi-mandatory as documented in that section.
  selection_mode: "coverage"

  # Maximum HiPS order (L = level_limit).
  #
  #   - Densmaps are computed for all depths 0..L.
  #   - Tiles (Norder*/Dir*/Npix*.tsv) are written for all depths 1..L
  #     until selection stops early (if no rows remain).
  #   - Must be between 4 and 11 inclusive; other values raise an error.
  level_limit: 11

  # HEALPix order used for:
  #   - The "coverage" densmap (densmaps[level_coverage]).
  #   - The MOC (Moc.fits / Moc.json).
  #
  # Densmaps themselves are computed for all depths 0..level_limit, but only
  # this one is used to build the MOC.
  level_coverage: 10

  # HEALPix order used for coverage cells (__icov__) in coverage mode
  # when use_hats_as_coverage=false or input.format!="hats".
  #
  #   - __icov__ is derived from RA/DEC at this HEALPix order.
  #   - The densmap at this order (if present) is used as a density proxy
  #     for density_bias_mode and targets_total_initial / targets_total_per_level.
  #
  # If densmaps does not contain this depth, density bias and total-target
  # scaling simply fall back to an un-biased profile; the pipeline still runs.
  #
  # In mag_global mode, this parameter is completely ignored: selection does
  # not use __icov__, and MOC/coverage computations depend only on
  # level_coverage.
  coverage_order: 10


  # ==============================
  # Coverage-based mode ONLY
  # (selection_mode: "coverage")
  # ==============================

  # When true and input.format == "hats":
  #   - Use HATS/LSDB partitions themselves as coverage cells (__icov__),
  #     instead of HEALPix cells at coverage_order.
  #   - The densmaps are still computed from RA/DEC, but coverage cells for
  #     selection follow the HATS layout.
  #   - density_bias_mode is effectively disabled in this path.
  #
  # Ignored if input.format != "hats" or selection_mode != "coverage".
  use_hats_as_coverage: false

  # Score ordering for coverage-based ranking:
  #   false → ascending: lower score is better.
  #   true  → descending: higher score is better.
  #
  # Applies only to coverage mode:
  #   - selection ranking inside each coverage cell.
  #   - threshold computation when filtering remainders between depths.
  order_desc: false

  # Density variation with depth for the base profile (k or total targets):
  #   "constant" → same base value at all depths.
  #   "linear"   → base value grows linearly with depth (1, 2, 3, ...).
  #   "exp"      → base value grows exponentially with depth.
  #   "log"      → base value grows roughly like log(depth).
  #
  # This profile is computed at each depth and then combined with the optional
  # per-level overrides and targets_total_per_level caps below.
  #
  # Used only in coverage mode; ignored in mag_global mode.
  density_mode: "exp"

  # Base expected number of rows per coverage cell (__icov__) at depth=1.
  #
  #   - Used as the amplitude of the density profile when
  #     targets_total_initial is None.
  #   - The per-depth target k_desired(depth) is derived from this profile.
  #
  # Mutually exclusive with targets_total_initial at the meaning level:
  # if targets_total_initial is not None, this value is ignored.
  k_per_cov_initial: 0.05

  # Base expected total number of rows at depth=1.
  #
  #   - When not None, the density profile is defined in terms of global totals:
  #       T_desired(depth) → k_desired(depth) = T_desired / N_cov(depth)
  #     where N_cov(depth) is the number of non-empty coverage cells at that
  #     depth, and k_per_cov_initial is ignored.
  #   - Used only in coverage mode.
  #
  # If both k_per_cov_initial and targets_total_initial are provided in the YAML,
  # load_config() raises a ValueError.
  # targets_total_initial: 150

  # Base used only when density_mode == "exp".
  #   - The profile scales roughly as base**(depth-1).
  # Used only in coverage mode.
  density_exp_base: 2

  # Density bias:
  #   "none"         → no density bias; k is uniform across coverage cells.
  #   "proportional" → k is larger in denser coverage cells.
  #   "inverse"      → k is larger in sparser coverage cells.
  #
  # Implemented using the densmap at coverage_order as density proxy. When the
  # densmap is empty or invalid, the pipeline automatically falls back to
  # "none" at runtime.
  #
  # Used only in coverage mode; ignored in mag_global mode.
  density_bias_mode: "proportional"

  # Power-law exponent controlling bias strength:
  #   - alpha = 0.5 → soft bias.
  #   - alpha = 1.0 → moderate bias.
  #   - alpha ≥ 2.0 → strong bias.
  #
  # The bias weights are proportional to density**alpha (or its inverse),
  # normalized so that the mean k remains close to the base profile.
  density_bias_exponent: 0.5

  # Optional per-level overrides for k_per_cov:
  #   depth: k_per_cov value (float, ≥0).
  #
  # Example:
  #   k_per_cov_per_level:
  #     3: 0.5
  #     5: 2.0
  #     7: 5.0
  #
  # When a depth appears here, the density profile value for that depth is
  # replaced by this value before applying any global total caps.
  #
  # Coverage mode only; ignored in mag_global mode.
  # k_per_cov_per_level:
  #   3: 0.5
  #   5: 2.0
  #   7: 5.0

  # Optional global caps: total target rows per depth (coverage mode).
  #
  #   - Mapping depth → total target rows (int ≥ 0).
  #   - After computing k_desired(depth) from the density profile (and any
  #     k_per_cov_per_level overrides), if a depth appears here the pipeline
  #     rescales k_desired so that the total expected rows do not exceed
  #     targets_total_per_level[depth].
  #
  # If the cap is smaller than what the base profile would give, the cap wins.
  #
  # Coverage mode only; ignored in mag_global mode.
  # targets_total_per_level:
  #   1: 1000
  #   2: 2000
  #   3: 4000

  # Fractional mode for the fractional part of k_desired (coverage mode):
  #   "random" → decisions are random (+1 with probability equal to the
  #              fractional part), independent of score.
  #   "score"  → extra rows are assigned to the best scores when needed.
  #
  # Used only in coverage mode. In mag_global mode, magnitude controls the
  # depth allocation and this flag is not used.
  fractional_mode: "score"

  # Scope for the fractional logic:
  #   "auto"   → backward-compatible:
  #                * if fractional_mode="random" → treat as "local".
  #                * if fractional_mode="score"  → treat as "global".
  #   "local"  → apply fractional decisions independently per coverage cell
  #              (__icov__).
  #   "global" → apply fractional decisions on the union of all coverage
  #              cells at a given depth (global ranking by score, then RA/DEC).
  #
  # Only relevant in coverage mode.
  fractional_mode_logic: "local"

  # Extra candidates per coverage cell near the cutoff (coverage mode).
  #
  #   - Before the exact reduction, the pipeline keeps k + tie_buffer candidates
  #     per coverage cell to reduce artifacts from score ties or rounding.
  #   - Must be a non-negative integer.
  #
  # Ignored in mag_global mode.
  tie_buffer: 2


  # ==============================
  # Global magnitude-complete mode ONLY
  # (selection_mode: "mag_global")
  # ==============================

  # Name of the magnitude column to use for:
  #   - Global ordering and histogram.
  #   - Computing mag_min / mag_max when not fully specified.
  #
  # Requirements when selection_mode="mag_global":
  #   - mag_column must not be None and must exist in the input.
  #   - Otherwise, the pipeline raises an error when preparing the input.
  #
  # Ignored when selection_mode="coverage".
  # mag_column: "mag_cModelFlux"

  # Magnitude range considered complete across all depths.
  #
  # Behavior when selection_mode="mag_global":
  #   - If mag_min is None:
  #       * The pipeline estimates a global minimum magnitude by sampling
  #         the input and taking the minimum value of mag_column.
  #       * This value is clipped so it is not smaller than -2.0 to avoid
  #         extreme outliers.
  #   - If mag_max is None:
  #       * The pipeline builds a global histogram of mag_column restricted
  #         to the interval (-2, 40).
  #       * It finds the bin with the maximum counts and uses the center of
  #         this bin as mag_max (according to the histogram resolution).
  #   - If both mag_min and mag_max are provided:
  #       * They are used as-is, and the histogram is built only inside this
  #         interval.
  #
  # In all cases, mag_min must be strictly less than mag_max, otherwise the
  # pipeline raises a ValueError.
  #
  # Ignored when selection_mode="coverage".
  # mag_min: 17.0
  # mag_max: 24.5

  # Number of bins for the global magnitude histogram (mag_global only).
  #
  #   - Controls the resolution of the CDF used to assign approximate targets
  #     per depth.
  #   - Must be a positive integer; invalid values raise a ValueError.
  #
  # Ignored when selection_mode="coverage".
  # mag_hist_nbins: 2048

  # Optional approximate global targets per depth (mag_global only).
  #
  #   - n_1, n_2, n_3 represent approximate desired total target counts for
  #     depths 1, 2 and 3 respectively.
  #   - They are used to shape the per-depth target profile. If the sum
  #     n_1 + n_2 + n_3 exceeds the total number of rows in the magnitude
  #     range, the pipeline rescales them to fit.
  #   - Any remaining targets for deeper orders are distributed according to
  #     the number of active tiles at each depth (from densmaps).
  #
  # Requirements:
  #   - n_2 is ignored unless n_1 is provided.
  #   - n_3 is ignored unless n_1 and n_2 are provided.
  #   - Each must be an integer ≥ 0; otherwise a ValueError is raised.
  #
  # Ignored when selection_mode="coverage".
  # n_1: 1000
  # n_2: 3000
  # n_3: 7000


# -----------------------------------------------------------------------------
# Cluster settings (Dask or SLURM)
# -----------------------------------------------------------------------------
cluster:
  # Execution mode for the Dask cluster:
  #   "local" → LocalCluster on the current machine.
  #   "slurm" → SLURMCluster via dask-jobqueue (requires dask-jobqueue installed).
  mode: slurm

  # Dask worker configuration (for both local and slurm modes):
  #   - n_workers          → number of worker processes.
  #   - threads_per_worker → threads per worker.
  #   - memory_per_worker  → memory limit per worker, as a string ("8GB", "32GB", etc.).
  n_workers: 20
  threads_per_worker: 8
  memory_per_worker: "12GB"

  # Memory vs throughput policy:
  #
  #   persist_ddfs:
  #     - true  → keep large intermediates (repartitioned ddf, remainders, etc.)
  #               in memory when possible (higher throughput, more memory).
  #     - false → do not persist; recompute from the Dask graph (lower memory).
  #
  #   avoid_computes_wherever_possible:
  #     - true  → prefer Dask-native reductions and avoid large .compute()
  #               on intermediate collections (more streaming, less peak memory).
  #     - false → follow the standard behavior with explicit .compute() calls.
  #
  # These flags affect both modes ("coverage" and "mag_global").
  persist_ddfs: false
  avoid_computes_wherever_possible: true

  # SLURM options (only used if mode: slurm)
  slurm:
    queue: "cpu_small"
    account: "hpc-bpglsst"
    job_extra_directives:
      - "--partition=cpu_small"
      - "--time=02:00:00"
    # Optional extras:
    # - "--constraint=..."
    # - "--qos=..."
    # - "--mem=0"   # use all node memory if allowed

    # Dask performance reports:
    # "none" → disabled, "local" → per-depth, "global" → full pipeline
    diagnostics_mode: global


# -----------------------------------------------------------------------------
# Output settings
# -----------------------------------------------------------------------------
output:
  # Output root directory for the HiPS hierarchy.
  # The pipeline will create subdirectories:
  #   - Norder*/Dir*/Npix*.tsv  (tiles)
  #   - Norder*/Allsky.tsv      (summary per depth, when applicable)
  #   - densmap_o*.fits         (densmaps)
  #   - Moc.fits / Moc.json     (MOC)
  #   - properties / metadata.xml
  #   - process.log             (full textual log)
  out_dir: "/scratch/users/luigi.silva/sky-viewer/docs/hipsgen_python_parallelized/LSST_DP1"

  # Catalog / HiPS name:
  #   - Used in metadata (properties, metadata.xml).
  #   - Used for some internal titles and logs.
  cat_name: "LSST_DP1"

  # Default sky position for visualization (RA DEC in degrees, space-separated).
  # Used only in metadata for visualization tools (e.g. Aladin) and does not
  # affect the selection logic.
  target: "0 0"

  # Unique IVOID identifier for this HiPS (recommended for HiPS 1.4).
  # Example: "ivo://YOUR_INSTITUTE/YourCatalogName"
  # Not strictly required by the pipeline, but some HiPS tools expect it.
  creator_did: "ivo://PRIVATE_USER/LSST_DP1"

  # Short human-readable title for the HiPS (required by HiPS 1.4 metadata).
  # Only affects descriptive metadata; no impact on the selection.
  obs_title: "LSST DP1 catalog"