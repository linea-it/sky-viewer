# =============================================================================
# HiPS Catalog Pipeline — config.yaml (CDS-aligned, bright-i first)
# =============================================================================
# This configuration mirrors the CDS tool semantics while reading Dask-native inputs.
# Key choices for “bright-i first”:
#   - order_desc: false  → ascending sort (CDS default)
#   - score: "MAG_AUTO_I_DERED" → lower magnitude = brighter → kept first
# If you prefer “negative mag + descending”, set:
#   columns.score: "-MAG_AUTO_I_DERED"
#   algorithm.order_desc: true

# -----------------------------------------------------------------------------
# Input catalog(s)
# -----------------------------------------------------------------------------
input:
  # One or more glob patterns. You can list multiple catalogs/partitions.
  # Parquet is ideal for performance; CSV/TSV are also supported.
  paths:
    - "/scratch/users/luigi.silva/curso-hpc/des_dr2_cut_spatial/*.parquet"

  # Input format (parquet | csv | tsv)
  format: parquet

  # For CSV/TSV only:
  # - true  → first non-comment row contains headers (column names)
  # - false → treat first row as data; RA/DEC may be referenced by numeric index (1-based)
  header: true

  # Optional hint for ASCII inputs:
  # - CSV or TSV. Other flavors from the original JAR (SSV/PSV/ASV/IPAC) are not supported here.
  # - When omitted, we infer from `format` (csv → ",", tsv → "\t").
  # ascii_format: CSV

# -----------------------------------------------------------------------------
# Column mapping and score definition
# -----------------------------------------------------------------------------
columns:
  # RA/DEC can be column names (usual case) or 1-based indices if `header: false` (CSV/TSV only).
  ra: RA
  dec: DEC

  # Score expression used for ranking within each HEALPix cell:
  # - single column (e.g., "MAG_AUTO_I_DERED")
  # - or an expression using available columns (e.g., "(FLUX_I/ERR_I)")
  # Ascending (order_desc: false) keeps the lowest values; descending keeps the highest.
  score: "MAG_AUTO_I_DERED"

  # Optional: explicit list of columns to keep in output tiles.
  # - RA/DEC and score dependencies are *always* preserved even if not listed here.
  # - If omitted or empty, all available columns are kept.
  keep:
    - MAG_AUTO_G_DERED
    # - MAG_AUTO_R_DERED
    # - ...

# -----------------------------------------------------------------------------
# Algorithmic controls (CDS-simple semantics + weighting method)
# -----------------------------------------------------------------------------
algorithm:
  # Simple mode (mirror of -simple):
  # - L1 (~n1) and L2 (~n2) quotas via LINEAR weights on counts
  # - L>=3 uses only `no` (ignores rl3l4/nm/nM)
  # - Default here is the *non-simple* mode for full CDS behavior.
  simple_algo: false

  # Sort direction inside each pixel:
  # - false (default) → ascending (CDS default): lowest scores are kept (e.g., smaller mags first)
  # - true            → descending: highest scores are kept
  order_desc: false

  # Weighting method for L1/L2 quota allocation:
  # LINEAR | LOG | ASINH | SQRT | POW2   (CDS default = LOG)
  method: LOG

  # Depth constraints (CDS bounds: 4 ≤ lM ≤ 11). lC ≤ lM.
  # lM = highest progressive order generated; lC = MOC coverage order.
  #level_limit: 11          # lM (tiles generated up to this order)
  #level_coverage: 10       # lC (MOC order)
  # Examples for quick tests:
  level_limit: 8
  level_coverage: 8

  # Global targets and per-pixel limits (CDS-like defaults)
  # L1/L2 (approximate totals, subject to availability and normalization):
  n1: 3000                 # Total rows kept at Norder1 (global target)
  n2: 6000                 # Total rows kept at Norder2 (global target)

  # Level 3:
  # quota_l3_per_pixel = clip(round(no * rl3l4), n3_min, n3_max), capped by availability
  n3_min: 3                # Min per pixel at Norder3
  # n3_max: 30000          # Optional cap at Norder3 (defaults to a high ceiling if omitted)

  # Levels ≥ 4:
  # Per-pixel quotas are capped by availability and clipped into [nm, nM] where possible.
  nm: 50                   # Min per pixel for depths ≥ 4 (if at least nm rows exist in the cell)
  nM: 500                  # Max per pixel for depths ≥ 4

  # Base quota reference:
  # - Used at L3 via rl3l4 (non-simple mode)
  # - Used directly for L≥3 in simple mode
  no: 500

  # Ratio to derive L3 quotas from `no` (non-simple mode only)
  rl3l4: 0.2

  # Optional early stop after generating L1/L2 only (useful for debugging or previews)
  l1l2_only: false

  # Optional: emit informational prints to stdout (similar to -p/--print_info)
  # - Reports total rows at each depth and per-depth write summaries.
  print_info: true

  # tie_buffer adds a small over-sampling margin per pixel (e.g., +16 rows) during
  # the two-pass selection. We first keep (quota + tie_buffer) candidates per ipix,
  # then apply a global, deterministic tie-break (score, RA, DEC) to cut back to
  # exactly the quota. This absorbs score ties at the cutoff and prevents “triangular”
  # artifacts caused by per-partition boundary effects.
  tie_buffer: 16

# -----------------------------------------------------------------------------
# Dask cluster settings
# -----------------------------------------------------------------------------
cluster:
  # Where to run:
  # - local → LocalCluster (single node; good for development/QA)
  # - slurm → SLURMCluster via dask-jobqueue (scale on HPC)
  mode: slurm

  # Concurrency knobs (both modes):
  n_workers: 20             # Number of workers (processes when processes=1 in SLURMCluster)
  threads_per_worker: 8     # Threads per worker
  memory_per_worker: "12GB" # Worker memory limit (e.g., "8GB", "24GB")

  # SLURM-only parameters (ignored in local mode)
  slurm:
    # Queue/partition and accounting (adapt to your site)
    queue: "cpu_small"           # e.g., cpu_dev | cpu_small | cpu
    account: "hpc-bpglsst"

    # Additional sbatch directives as strings; they are passed verbatim.
    job_extra_directives:
      - "--partition=cpu_small"
      - "--time=02:00:00"

# -----------------------------------------------------------------------------
# Output location and metadata
# -----------------------------------------------------------------------------
output:
  # Root directory for generated HiPS artifacts (tiles, Allsky.tsv, properties,
  # Moc.fits/json, nhhtree/metadata.info, densmap_o*.fits, metadata.xml).
  out_dir: "/scratch/users/luigi.silva/hipsgencat/DES_DR2_small_sample"

  # Label shown in "properties" and metadata. Keep stable for a given dataset/version.
  cat_name: "DES_DR2_small_sample"

  # Viewer initial pointing (metadata only; does not affect selection)
  target: "0 0"            # "<RA0> <DEC0>", e.g., "180 -30"

# -----------------------------------------------------------------------------
# Debug
# -----------------------------------------------------------------------------
debug:
  origin: false            # create __src__ by concatenating files (no include_path_column)
  ranges_check: false     # optional
  containment_check: false # optional: “selected ⊆ input” via (RA,DEC,MAG) hash